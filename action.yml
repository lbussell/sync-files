name: 'Sync Files'
description: 'Synchronizes a file or directory from another GitHub repository via Pull Request'

inputs:
  github_token:
    description: 'GitHub token (needs read access on source repo, write access on target)'
    required: true
  source_repo:
    description: 'Source repository in format owner/repo'
    required: true
  source_path:
    description: 'Path to file or directory in source repository'
    required: true
  target_path:
    description: 'Destination path in current repository (defaults to source_path)'
    required: false
    default: ''
  target_branch:
    description: 'Target branch for the PR'
    required: false
    default: 'main'

outputs:
  pr_url:
    description: 'URL of the created or updated PR (empty if no changes)'
    value: ${{ steps.create-pr.outputs.pr_url }}
  pr_number:
    description: 'Number of the created or updated PR (empty if no changes)'
    value: ${{ steps.create-pr.outputs.pr_number }}

runs:
  using: "composite"
  steps:
    - name: Validate inputs
      id: validate
      shell: bash
      env:
        SOURCE_REPO: ${{ inputs.source_repo }}
        SOURCE_PATH: ${{ inputs.source_path }}
        TARGET_PATH: ${{ inputs.target_path }}
      run: |
        # Validate source_repo format (owner/repo)
        if [[ ! "$SOURCE_REPO" =~ ^[a-zA-Z0-9._-]+/[a-zA-Z0-9._-]+$ ]]; then
          echo "::error::Invalid source_repo format: $SOURCE_REPO. Expected format: owner/repo"
          exit 1
        fi

        # Validate source_path is not empty
        if [[ -z "$SOURCE_PATH" ]]; then
          echo "::error::source_path cannot be empty"
          exit 1
        fi

        # Set target_path to source_path if not provided
        if [[ -z "$TARGET_PATH" ]]; then
          TARGET_PATH="$SOURCE_PATH"
        fi
        echo "target_path=$TARGET_PATH" >> "$GITHUB_OUTPUT"

        # Generate sanitized path for branch name
        SANITIZED_PATH=$(echo "$SOURCE_PATH" | sed 's/[^a-zA-Z0-9]/-/g' | sed 's/--*/-/g' | sed 's/^-//' | sed 's/-$//' | cut -c1-30)
        echo "sanitized_path=$SANITIZED_PATH" >> "$GITHUB_OUTPUT"

    - name: Checkout target repository
      uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # v6.0.2
      with:
        ref: ${{ inputs.target_branch }}
        fetch-depth: 0
        token: ${{ inputs.github_token }}

    - name: Checkout source repository
      uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # v6.0.2
      with:
        repository: ${{ inputs.source_repo }}
        path: .sync-source
        token: ${{ inputs.github_token }}
        sparse-checkout: ${{ inputs.source_path }}
        sparse-checkout-cone-mode: false

    - name: Copy files and detect changes
      id: copy-files
      shell: bash
      env:
        SOURCE_PATH: ${{ inputs.source_path }}
        TARGET_PATH: ${{ steps.validate.outputs.target_path }}
      run: |
        SOURCE_FULL=".sync-source/$SOURCE_PATH"

        # Check if source exists
        if [[ ! -e "$SOURCE_FULL" ]]; then
          echo "::error::Source path does not exist: $SOURCE_PATH"
          exit 1
        fi

        # Determine if source is file or directory
        if [[ -d "$SOURCE_FULL" ]]; then
          echo "Syncing directory: $SOURCE_PATH -> $TARGET_PATH"

          # Remove trailing slashes for consistent behavior
          SOURCE_CLEAN="${SOURCE_FULL%/}"
          TARGET_CLEAN="${TARGET_PATH%/}"

          # Create target directory and sync contents
          mkdir -p "$TARGET_CLEAN"
          rm -rf "$TARGET_CLEAN"/*
          cp -r "$SOURCE_CLEAN"/* "$TARGET_CLEAN"/
        else
          echo "Syncing file: $SOURCE_PATH -> $TARGET_PATH"

          # Create parent directory if needed
          mkdir -p "$(dirname "$TARGET_PATH")"

          # Copy file
          cp "$SOURCE_FULL" "$TARGET_PATH"
        fi

        # Cleanup source checkout
        rm -rf .sync-source

        # Check for changes
        if [[ -z "$(git status --porcelain)" ]]; then
          echo "No changes detected"
          echo "has_changes=false" >> "$GITHUB_OUTPUT"
        else
          echo "Changes detected:"
          git status --short
          echo "has_changes=true" >> "$GITHUB_OUTPUT"

          # Generate content hash for branch naming
          CONTENT_HASH=$(git status --porcelain | sha256sum | cut -c1-8)
          echo "content_hash=$CONTENT_HASH" >> "$GITHUB_OUTPUT"
        fi

    - name: Create branch and commit
      id: commit
      if: steps.copy-files.outputs.has_changes == 'true'
      shell: bash
      env:
        SANITIZED_PATH: ${{ steps.validate.outputs.sanitized_path }}
        CONTENT_HASH: ${{ steps.copy-files.outputs.content_hash }}
        SOURCE_REPO: ${{ inputs.source_repo }}
        SOURCE_PATH: ${{ inputs.source_path }}
        TARGET_PATH: ${{ steps.validate.outputs.target_path }}
      run: |
        # Configure git
        git config user.name "github-actions[bot]"
        git config user.email "github-actions[bot]@users.noreply.github.com"

        # Create branch name
        BRANCH_NAME="sync-files/${SANITIZED_PATH}-${CONTENT_HASH}"
        echo "branch_name=$BRANCH_NAME" >> "$GITHUB_OUTPUT"

        # Create branch from current state (force-push will update remote if it exists)
        git checkout -B "$BRANCH_NAME"

        # Stage and commit changes
        git add -A
        git commit -m "Sync files from $SOURCE_REPO

        Synced: $SOURCE_PATH -> $TARGET_PATH

        Source repository: https://github.com/$SOURCE_REPO"

        # Push (force to update if branch existed)
        git push -u origin "$BRANCH_NAME" --force

    - name: Create or update PR
      id: create-pr
      if: steps.copy-files.outputs.has_changes == 'true'
      uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd # v8.0.0
      env:
        BRANCH_NAME: ${{ steps.commit.outputs.branch_name }}
        TARGET_BRANCH: ${{ inputs.target_branch }}
        SOURCE_REPO: ${{ inputs.source_repo }}
        SOURCE_PATH: ${{ inputs.source_path }}
        TARGET_PATH: ${{ steps.validate.outputs.target_path }}
      with:
        github-token: ${{ inputs.github_token }}
        script: |
          const branchName = process.env.BRANCH_NAME;
          const targetBranch = process.env.TARGET_BRANCH;
          const sourceRepo = process.env.SOURCE_REPO;
          const sourcePath = process.env.SOURCE_PATH;
          const targetPath = process.env.TARGET_PATH;

          // Check for existing PR
          const { data: existingPRs } = await github.rest.pulls.list({
            owner: context.repo.owner,
            repo: context.repo.repo,
            head: `${context.repo.owner}:${branchName}`,
            base: targetBranch,
            state: 'open'
          });

          let pr;
          if (existingPRs.length > 0) {
            pr = existingPRs[0];
            core.info(`Found existing PR #${pr.number}, branch updated`);
          } else {
            const { data: newPR } = await github.rest.pulls.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: `Sync ${sourcePath} from ${sourceRepo}`,
              head: branchName,
              base: targetBranch,
              body: `## File Sync

          This PR synchronizes files from another repository.

          | Property | Value |
          |----------|-------|
          | **Source Repository** | [${sourceRepo}](https://github.com/${sourceRepo}) |
          | **Source Path** | \`${sourcePath}\` |
          | **Target Path** | \`${targetPath}\` |

          ---
          *This PR was automatically created by the sync-files action.*`
            });
            pr = newPR;
            core.info(`Created new PR #${pr.number}`);
          }

          core.setOutput('pr_url', pr.html_url);
          core.setOutput('pr_number', pr.number.toString());

    - name: Set empty outputs when no changes
      if: steps.copy-files.outputs.has_changes != 'true'
      shell: bash
      run: |
        echo "No changes detected, skipping PR creation"
